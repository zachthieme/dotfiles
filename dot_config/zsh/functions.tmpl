#!/usr/bin/zsh

function gff () {
  if [ -z "$1" ]; then
    echo "\033[31mError:\033[0m Please provide a file path."
    echo "Usage: git_file_preview <file>"
    return 1
  fi

  local file="$1"

  # Get the full relative path of the file from the repository root
  local repo_root=$(git rev-parse --show-toplevel)
  local rel_file="${file#$repo_root/}"

  echo "\033[34mSearching Git history for:\033[0m $rel_file"

  # Use fzf to interactively search and preview file history
  local selected_commit
  selected_commit=$(git log --oneline --follow -- "$rel_file" | \
    fzf --preview "git show {1}:$rel_file | cat --paging=always --style=plain" \
        --preview-window=right:70%:wrap --height=80% --border)

  if [ -z "$selected_commit" ]; then
    echo "\033[33mNo commit selected.\033[0m"
    return 0
  fi

  local commit_hash
  commit_hash=$(echo "$selected_commit" | awk '{print $1}')

  echo "\033[34mSelected Commit:\033[0m $commit_hash"
  echo "\033[34mFile Content at Commit:\033[0m"

  # Use bat to display the file's content with syntax highlighting
  git show "$commit_hash:$rel_file" | bat --paging=always --style=plain
}

# kill command using fzf
function k() {
  ps aux | 
  fzf --height 40% \
      --layout=reverse \
      --header-lines=1 \
      --prompt="Select process to kill: " \
      --preview 'echo {}' \
      --preview-window up:3:hidden:wrap \
      --bind 'F2:toggle-preview' |
  awk '{print $2}' |
  xargs -r bash -c '
      if ! kill "$1" 2>/dev/null; then
          echo "Regular kill failed. Attempting with sudo..."
          sudo kill "$1" || echo "Failed to kill process $1" >&2
      fi
  ' --
}

function logg() {
    git log | fzf --ansi --no-sort \
        --preview 'echo {} | grep -o "[a-f0-9]\{7\}" | head -1 | xargs -I % git show % --color=always' \
        --preview-window=right:50%:wrap --height 100% \
        --bind 'enter:execute(echo {} | grep -o "[a-f0-9]\{7\}" | head -1 | xargs -I % sh -c "git show % | nvim -c \"setlocal buftype=nofile bufhidden=wipe noswapfile nowrap\" -c \"nnoremap <buffer> q :q!<CR>\" -")' \
        --bind 'ctrl-e:execute(echo {} | grep -o "[a-f0-9]\{7\}" | head -1 | xargs -I % sh -c "gh browse %")' \
}

function mkdd ()
{
 mkdir -p ${1:+$1$prefix_separator}"$(date +%F)"; }

# Common function to search for a string in files using rga and fzf, and opens the file with nvim.
function _fif_common() {
  local ignore_case_flag="$1"
  local chezmoi="$3"
  shift

  local files
  local preview_cmd=$(printf "rg %s --pretty --context 10 '%s' {}" "$ignore_case_flag" "$1")
  local rga_output=$(rg --max-count=1 $ignore_case_flag --files-with-matches --no-messages "$1")
  IFS=$'\n' files=($(echo "$rga_output" | fzf-tmux +m --preview="$preview_cmd" --multi --select-1 --exit-0)) || return 1

  if [ ${#files[@]} -eq 0 ]; then
    echo "No files selected."
    return 0
  fi

  typeset -a temp_files
  for i in {1..${#files[@]}}; do
    if [[ -n "${files[i]}" ]]; then
      temp_files[i]=$(realpath "${files[i]}")
    fi
  done
  files=("${temp_files[@]}")
  local nvim_cmd=""
      if [[ $chezmoi == "--chezmoi" ]]; then
        nvim_cmd="cm edit \"${files[@]}\""
      else
        nvim_cmd="nvim \"${files[@]}\""
      fi 

  eval "$nvim_cmd"
}

# Wrapper function for case-sensitive search
function fifs() {
    _fif_common "" "$@"
}

# Wrapper function for case-sensitive search
function fifc() {
    _fif_common "" "$@" "--chezmoi"
}

# Wrapper function for case-insensitive search
function fif() {
    _fif_common "--ignore-case" "$@"
}

function y() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    builtin cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}
